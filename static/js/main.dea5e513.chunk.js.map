{"version":3,"sources":["components/SongList/SongList.module.scss","components/Player/PlayerControls/PlayerControls.module.scss","components/Box/Box.module.scss","components/UI/IconButton/IconButton.module.scss","components/UI/IconLink/IconLink.module.scss","components/Grid/Grid.module.scss","../../../../src/players/Protracker/constants.ts","../../src/utils.ts","../../../../src/players/Protracker/ProtrackerReader.ts","../../../src/players/players.ts","../../src/Wurlitzer.ts","components/Box/Box.tsx","components/Grid/Grid.tsx","components/Header/Header.tsx","components/UI/IconButton/IconButton.tsx","components/Player/PlayerControls/PlayerControls.tsx","components/UI/IconLink/IconLink.tsx","components/SongList/SongList.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","AMIGA_CLOCK_SPEED","loadFile","source","loadFileFromUrl","loadFileFromDisk","Promise","resolve","reject","reader","FileReader","onload","result","onerror","onabort","console","log","readAsArrayBuffer","req","XMLHttpRequest","open","responseType","response","ontimeout","send","readStringFromArrayBuffer","arrayBuffer","start","end","String","fromCharCode","apply","Array","from","Uint8Array","slice","getChannelCount","fileData","signature","getSignature","channelCount","test","parseInt","substr","headerStart","name","getInitOptions","type","getFormatDescription","isFileSupported","Error","outputCount","numberOfOutputs","outputChannelCount","map","item","processorOptions","options","path","audioContext","connected","status","onMessage","event","data","info","stop","this","window","AudioContext","webkitAudioContext","globalThis","loadPlayer","player","port","onmessage","mixer","addAmigaMixer","_disconnect","postMessage","cmd","_connect","index","newPosition","connect","destination","disconnect","ChannelMergerNode","numberOfInputs","forEach","filter","requiredPlayer","e","AudioWorkletNode","audioWorklet","addModule","box","props","className","css","Box","orange","children","grid","Grid","header","iconButton","IconButton","onClick","title","icon","boxImage","song","src","process","image","alt","PlayerControls","imageContainer","currentSong","songName","format","channels","size","buttons","faPlayCircle","play","faPauseCircle","pause","faStopCircle","iconLink","href","IconLink","songList","songTable","list","key","noWrap","load","faFileDownload","mobileSongTable","mobileSong","mobileSongTitle","mobileSongInfo","mobileSongControls","songs","App","useState","undefined","setCurrentSong","ready","setReady","setPlayer","Header","SongList","p","Wurlitzer","then","style","textAlign","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.dea5e513.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"songTable\":\"SongList_songTable__3iwG3\",\"noWrap\":\"SongList_noWrap__dxJ0t\",\"mobileSongTable\":\"SongList_mobileSongTable__2lNnP\",\"mobileSong\":\"SongList_mobileSong__LpCCG\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"buttons\":\"PlayerControls_buttons__2Q_jW\",\"imageContainer\":\"PlayerControls_imageContainer__1cIVJ\",\"boxImage\":\"PlayerControls_boxImage__VEoIC\",\"songName\":\"PlayerControls_songName__1eDfD\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Box\":\"Box_Box__1zQUc\",\"orange\":\"Box_orange__OLv20\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"IconButton\":\"IconButton_IconButton__ovxH-\",\"icon\":\"IconButton_icon__3_7uf\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"IconLink\":\"IconLink_IconLink__3PrTB\",\"icon\":\"IconLink_icon__3kPXE\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Grid\":\"Grid_Grid__1He54\"};","import { WaveType } from \"./models/WaveType.interface\";\n\nexport const AMIGA_CLOCK_SPEED_NTSC = 7159090.5;\nexport const AMIGA_CLOCK_SPEED_PAL = 7093789.2;\n\nexport enum AMIGA_CLOCK_SPEED {\n    NTSC = AMIGA_CLOCK_SPEED_NTSC,\n    PAL  = AMIGA_CLOCK_SPEED_PAL\n}\n\nexport const EFFECT_CODES = {\n    ARPEGGIO:                     '0',           // √\n    PORTAMENTO_UP:                '1',           // √\n    PORTAMENTO_DOWN:              '2',           // √\n    TONE_PORTAMENTO:              '3',           // √\n    VIBRATO:                      '4',           // √\n    VOLUME_SLIDE_TONE_PORTAMENTO: '5',           // √\n    VOLUME_SLIDE_VIBRATO:         '6',           // √\n    TREMOLO:                      '7',           // √\n    SET_PANNING_POSITION:         '8',\n    SET_SAMPLE_OFFSET:            '9',           // √\n    VOLUME_SLIDE:                 '10',          // √\n    POSITION_JUMP:                '11',          // √\n    SET_VOLUME:                   '12',          // √\n    PATTERN_BREAK:                '13',          // √\n    SET_FILTER:                   '14-0',\n    FINE_PORTAMENTO_UP:           '14-1',        // √\n    FINE_PORTAMENTO_DOWN:         '14-2',        // √\n    GLISSANDO:                    '14-3',\n    SET_VIBRATO_WAVEFORM:         '14-4',        // √\n    SET_FINE_TUNE:                '14-5',        // √\n    PATTERN_LOOP:                 '14-6',        // √\n    SET_TREMOLO_WAVEFORM:         '14-7',        // √\n    // UNUSED:                    '14-8'\n    RETRIGGER_NOTE:               '14-9',        // √\n    FINE_VOLUME_SLIDE_UP:         '14-10',       // √\n    FINE_VOLUME_SLIDE_DOWN:       '14-11',       // √\n    NOTE_CUT:                     '14-12',       // √\n    NOTE_DELAY:                   '14-13',       // √\n    PATTERN_DELAY:                '14-14',       // √\n    FUNKREPEAT:                   '14-15',\n    SET_SPEED:                    '15',          // √\n};\n\nexport const WAVE_TYPES: WaveType[] = ['sine', 'sawtooth', 'square', 'random']; // Do not re-order!\n\nexport const UNKNOWN_FORMAT = 'Unknown format';\n","export function createAudioContext(): AudioContext {\n    return typeof window  !== 'undefined'\n        ? new (window.AudioContext || (window as any).webkitAudioContext)()\n        : globalThis as unknown as AudioContext;\n}\n\nexport async function loadFile(source: string | File): Promise<ArrayBuffer> {\n    return (typeof source === 'string' ? loadFileFromUrl(source) : loadFileFromDisk(source))\n}\n\nexport function loadFileFromDisk(source: File): Promise<ArrayBuffer> {\n    return new Promise((resolve: Function, reject: Function) => {\n        const reader = new FileReader;\n\n        reader.onload = () => {\n            resolve(reader.result as ArrayBuffer);\n        };\n        reader.onerror = () => {\n            reject(\"TIMEOUT\");\n        };\n        reader.onabort = () => {\n            reject('ABORT');\n        };\n\n        console.log(`[INFO] Attempting to read file:`, source);\n        reader.readAsArrayBuffer(source);\n    });\n}\n\nexport function loadFileFromUrl(source: string): Promise<ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n        const req = new XMLHttpRequest();\n        req.open('GET', source, true);\n        req.responseType = 'arraybuffer';\n\n        req.onload = () => {\n            if(req.response) {\n                resolve(req.response);\n            }\n            else {\n                reject(\"EMPTY\");\n            }\n        }\n        req.onerror = function() {\n            reject(\"ERROR\");\n        };\n        req.ontimeout = function() {\n            reject(\"TIMEOUT\");\n        };\n        req.onabort = function() {\n            reject('ABORT');\n        };\n\n        console.log(`[INFO] Attempting to read file from URL: '${source}'`);\n        req.send();\n    });\n};\n\nexport function pickRandom(...params: any[]) {\n    return params[randomInt(params.length)];\n}\n\n/**\n * Given a max of 3, it will return 0,1,2\n */\nexport function randomInt(max: number): number {\n    return Math.floor(Math.random() * Math.floor(max));\n}\n\nexport function read8bitInt(arrayBuffer: ArrayBuffer, offset: number) {\n    return new DataView(arrayBuffer).getUint8(offset);\n};\n\nexport function readBigEndian16bitInt(arrayBuffer: ArrayBuffer, offset: number) {\n    return new DataView(arrayBuffer).getUint16(offset, false);\n};\n\nexport function readStringFromArrayBuffer(arrayBuffer: ArrayBuffer, start: number, end?: number) {\n    return String.fromCharCode.apply(\n        null,\n        Array.from(new Uint8Array(arrayBuffer.slice(start, end)))\n    );\n};\n","import { EffectCode } from './models/EffectCode.interface';\nimport { Instruction } from './models/Instruction.interface';\nimport { Sample } from './models/Sample.interface';\nimport { SampleHeader } from './models/SampleHeader.interface';\n\nimport * as constants from './constants';\nimport * as utils from '../../utils'\n\n/****************************\n *     Public functions     *\n ****************************/\nexport function getChannelCount(fileData: ArrayBuffer): number {\n    const signature = getSignature(fileData);\n    let channelCount: number = 4;\n\n    switch(signature) {\n        case '8CHN':\n        case 'FLT8':\n        case 'CD81':\n        case 'OKTA':\n        case 'OCTA':\n            channelCount = 8;\n            break;\n        case '6CHN':\n            channelCount = 6;\n            break;\n        case '2CHN':\n            channelCount = 2;\n            break;\n        default:\n            if(/^[0-9][0-9]C[H,N]$/.test(signature)) {\n                channelCount = parseInt(signature.substr(0,2));\n            }\n            else if(/^TDZ[0-9]$/.test(signature)) {\n                channelCount = parseInt(signature.substr(3));\n            }\n            else if(/^[579]CHN$/.test(signature)) {\n                channelCount = parseInt(signature.substr(0,1));\n            }\n    }\n\n    return channelCount;\n};\n\nexport function getFormatDescription(fileData: ArrayBuffer): string {\n    const signature = getSignature(fileData);\n    let type: string = constants.UNKNOWN_FORMAT;\n\n    switch(signature) {\n        case 'M.K.':\n            type = 'ProTracker';\n            break;\n        case 'M!K!':\n        case 'M&K!':\n            type = 'ProTracker (extended patterns)';\n            break;\n        case '6CHN':\n            type = 'ProTracker (6 channels)';\n            break;\n        case '8CHN':\n            type = 'ProTracker (8 channels)';\n            break;\n        case '2CHN':\n            type = 'FastTracker (2 channels)';\n            break;\n        case 'CD81':\n        case 'OKTA':\n            type = 'Oktalyzer';\n            break;\n        case 'OCTA':\n            type = 'Octamed';\n            break;\n        case 'FLT4':\n            type = 'StarTrekker';\n            break;\n        case 'FLT8':\n            type = 'StarTrekker (8 channels)';\n            break;\n        default:\n            if(/^[0-9][0-9]CH$/.test(signature)){\n                type = `FastTracker (${parseInt(signature.substr(0,2))} channels)`;\n            }\n            if(/^[0-9][0-9]CN$/.test(signature)){\n                type = `TakeTracker (${parseInt(signature.substr(0,2))} channels)`;\n            }\n            else if(/^TDZ[0-9]$/.test(signature)){\n                type = `TakeTracker (${parseInt(signature.substr(3))} channels)`;\n            }\n            else if(/^[579]CHN$/.test(signature)){\n                type = `TakeTracker (${parseInt(signature.substr(0,1))} channels)`;\n            }\n    }\n\n    return type;\n};\n\n/*\n    Returns the data required to create a new AudioWorkletNode\n    This allows the protracker playback code to be executed in its own thread\n*/\nexport function getInitOptions(fileData: ArrayBuffer): AudioWorkletNodeOptions {\n    if(!isFileSupported(fileData)) throw new Error;\n    const outputCount = getChannelCount(fileData)\n    return {\n        numberOfOutputs: outputCount,\n        outputChannelCount: [...new Array(outputCount)].map(item => 1),\n        processorOptions: {\n            fileData: fileData\n        }\n    }\n}\n\n/*\n    This scans through the pattern sequence table to find the highest pattern index.\n    That is the number of patterns used by the module.\n\n    The song may not use all of these though, it may be that some patterns were edited,\n    but never intended to be played (imagine devs working to a deadline)\n*/\nexport function getPatternCount(fileData: ArrayBuffer): number {\n    const patternSequence = getPatternSequence(fileData);\n\n    // Pattern count is the largest pattern index + 1 (as patterns are zero-indexed)\n    return patternSequence.reduce((a,b) => Math.max(a,b)) + 1;\n};\n\n/*\n    This loads all of the pattern data into the pattern data array.\n    The pattern data array is split up into single channel rows.\n    So that means we have a 3D array - [pattern][channel][rows].\n\n    I should also mention the structure of how a channels pattern data\n    is set out. It is comprised of 32 bits (4 bytes):\n\n    #1           #2                  #3         #4\n    0000         0000-00000000       0000       0000-0000000\n\n    #1 = first 4 bits are the UPPER 4 bits of the sample number\n    #2 = 12 bits, this is the note period.\n    #3 = 4 bits, this is the LOWER 4 bits of the sample number\n    #4 = 12 bits, effect command. Can be split into 4bit effect command and 8bit parameter.\n\n    The pattern data is set out as above in 4 byte chunks in the file.\n    The row data for each channel is stored in order, so the file is like so:\n\n    [channel0row0-4bytes][channel1row0-4bytes][channel2row0-4bytes][channel3row0-4bytes]\n    [channel0row1-4bytes][channel1row1-4bytes][channel2row1-4bytes][channel3row1-4bytes]\n    etc...\n\n    If the file has more than 4 channels, it should just follow suit as above (so if there\n    are 8 channels, it would be [ch0][ch1][ch2][ch3][ch4][ch5][ch6][ch7] and carry on like\n    that for 64 rows). The exception is if the signature FLT8, where instead of having\n    8 instructions per row, it has 4 instructions per row and uses two patterns worth of\n    rows to create one 8-channel pattern. E.G - the first pattern has [ch0][ch1][ch2][ch3]\n    for 64 rows, then the next pattern has [ch4][ch5][ch6][ch7] for 64 rows. You then have\n    to stick these back together.\n*/\nexport function getPatterns(fileData: ArrayBuffer): Instruction[][][] {\n    const channelCount = getChannelCount(fileData);\n    const patterns: Instruction[][][] = [];\n    const start = 20 + (30*31) + 1 + 1 + 128 + 4;\n    const patternCount = getPatternCount(fileData);\n    const view = new DataView(fileData);\n\n    let i, j, k, top, bottom;\n\n    // Loop through patterns\n    for(i=0; i<patternCount; i++) {\n        patterns[i] = [];\n\n        // Loop through rows in the pattern\n        for(j=0; j<64; j++) {\n            patterns[i][j] = [];\n\n            // Loop through channels in the row\n            for(k=0; k<channelCount; k++) {\n                patterns[i][j][k] = {} as Instruction;\n\n                // Sample number\n                // We shift right by 4 bits and then left by 4 bits to remove the lower 4 bits.\n                top = (view.getUint8(start + (i*64*channelCount*4) + (j*channelCount*4) + (k*4)) >> 4) << 4;\n                bottom = view.getUint8(start + (i*64*channelCount*4) + (j*channelCount*4) + (k*4) + 2) >> 4;\n                patterns[i][j][k].sampleIndex = top + bottom;\n\n                // period - represented by bottom 4 bits in the first byte and the second byte (12 byte number).\n                // We get the lower 4 bits by using the modulus of 16 (remainder of dividing by 16).\n                top = (view.getUint8(start + (i*64*channelCount*4) + (j*channelCount*4) + (k*4)) % 16) << 8;\n                bottom = view.getUint8(start + (i*64*channelCount*4) + (j*channelCount*4) + (k*4) + 1);\n                patterns[i][j][k].period = top + bottom;\n\n                // Effect - get the lower 4 bits of byte 3 by using modulus 16.\n                top = view.getUint8(start + (i*64*channelCount*4) + (j*channelCount*4) + (k*4) + 2) % 16;\n                bottom =  view.getUint8(start + (i*64*channelCount*4) + (j*channelCount*4) + (k*4) + 3);\n                if(top > 0 || bottom > 0) {\n                    patterns[i][j][k].effect = {\n                        code: top,\n                        p:    bottom,\n                        px:   (bottom >> 4),\n                        py:   (bottom % 16)\n                    };\n                }\n            }\n        }\n    }\n\n    return patterns;\n};\n\nexport function getPatternSequence(fileData: ArrayBuffer): number[] {\n    const patternSequenceData = fileData.slice(952, 1080);\n\n    let i;\n    let lastIndex = 0;\n    let patternSequence: number[] = [];\n\n    // Convert pattern sequence bytes to an integer array (they are big endian in the file)\n    for(i=0; i<128; i++) {\n        patternSequence[i] = utils.read8bitInt(patternSequenceData, i);\n    };\n\n    // Find out where the last pattern index is (the sequence is zero-padded)\n    for(i=patternSequence.length-1; i>=0; i--) {\n        if(patternSequence[i] !== 0) {\n            lastIndex = i;\n            break;\n        }\n    }\n\n    // Return pattern sequence, trimming off zero-padding\n    return patternSequence.slice(0, lastIndex + 1)\n};\n\nexport function getRowsPerPattern(fileData: ArrayBuffer): number {\n    const signature = getSignature(fileData);\n\n    switch(signature) {\n        case 'M!K!':\n            return 128;\n        default:\n            return 64;\n    }\n};\n\nexport function getSampleCount(): number {\n    return 31;\n};\n\nexport function getSamples(fileData: ArrayBuffer, addExtraEndSample: boolean = false): Sample[] {\n    const channelCount = getChannelCount(fileData);\n    const patternCount = getPatternCount(fileData);\n    const samples: Sample[] = [];\n\n    let audio;\n    let data;\n    let header;\n    let headerDataStartOffset = 20;\n    let sampleAudioStartOffset = 20 + (30*31) + 1 + 1 + 128 + 4 + (patternCount * 64 * channelCount * 4);\n    let sampleHeaderData;\n    let i;\n\n    // Run through and extract header and audio data for all samples\n    for(i=0; i<31; i++) {\n        // Each header is 30 bytes, extract them, then decode. Increment start offset position by 30 for next read.\n        sampleHeaderData = fileData.slice(headerDataStartOffset, headerDataStartOffset + 30);\n        header = _getSampleHeader(sampleHeaderData);\n        headerDataStartOffset = headerDataStartOffset + 30;\n\n        // Extract audio data - the length of the sample comes from the header\n        data = fileData.slice(sampleAudioStartOffset, sampleAudioStartOffset + header.length);\n        audio = _getSampleAudio(data, addExtraEndSample);\n        sampleAudioStartOffset = sampleAudioStartOffset + header.length;\n\n        // Concatenate and add to samples array\n        samples[i] = {\n            ...header,\n            audio\n        }\n    };\n\n    return samples;\n};\n\nexport function getSignature(fileData: ArrayBuffer): string {\n    const headerStart = 20 + (30*31) + 1 + 1 + 128;\n    return utils.readStringFromArrayBuffer(fileData, headerStart, headerStart + 4);\n}\n\nexport function getSongLoopPatternSequenceIndex(fileData: ArrayBuffer): number | undefined {\n    const start = 20 + (30*31) + 1;\n    const value = utils.read8bitInt(fileData, start)\n\n    // If value < 127, it signifies loop index. Otherwise, there is no loop (return undefined).\n    // return (value < 127) ? value : undefined;\n\n    // Oddly, it seems you should always return 0 for this...?\n    return 0;\n};\n\nexport function getTitle(fileData: ArrayBuffer): string {\n    return utils.readStringFromArrayBuffer(fileData, 0, 20).replace(/\\u0000/g, ' ').trim();\n};\n\n/*\n    This figure is the number of pattern sequence positions used by the song\n*/\nexport function getUsedPatternSequenceLength(fileData: ArrayBuffer): number {\n    const start = 20 + (30*31);\n    return utils.read8bitInt(fileData, start);\n}\n\nexport function isFileSupported(fileData: ArrayBuffer): boolean {\n    return getFormatDescription(fileData) !== constants.UNKNOWN_FORMAT;\n}\n\n\n/*****************************\n *     Private functions     *\n *****************************/\n\n/*\n    Value:    0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n    Finetune: 0  +1  +2  +3  +4  +5  +6  +7  -8  -7  -6  -5  -4  -3  -2  -1\n*/\nfunction _getFineTuneValue(rawInteger: number): number {\n    if(rawInteger >= 8)  {\n        return -16 + rawInteger\n    }\n    else {\n        return rawInteger;\n    }\n};\n\nfunction _getSampleAudio(sampleData: ArrayBuffer, addExtraEndSample: boolean = false): Float32Array {\n    const float32Samples = new Float32Array(sampleData.byteLength + (addExtraEndSample ? 1 : 0));\n    const view = new DataView(sampleData);\n\n    let i;\n\n    // Run through samples and convert from signed 8-bit int to signed float32\n    for(i=0; i<sampleData.byteLength; i++) {\n        float32Samples[i] = view.getInt8(i) / 128.00;\n    }\n\n    // This is really confusing. Imagine you have a sample 8 bytes long. You can set the loop length to be 8,\n    // which you can image as 'a loop length of 8 wave sections'. However, you actually need 9 samples to be\n    // able to loop 8 wave sections. So, to sort this, we fudge it by duplicating the last sample. You can check\n    // milkytracker on this, it does the same. If you don't do this, very short looping samples will sound noticably\n    // higher pitched.\n    if(addExtraEndSample) {\n        if(addExtraEndSample) {\n            float32Samples[i] = float32Samples[i - 1];\n        }\n    }\n\n    return float32Samples;\n};\n\nfunction _getSampleHeader(sampleHeaderData: ArrayBuffer): SampleHeader {\n    return {\n        name:         utils.readStringFromArrayBuffer(sampleHeaderData, 0, 22),\n        length:       utils.readBigEndian16bitInt(sampleHeaderData, 22) * 2,\n        fineTune:     _getFineTuneValue(utils.read8bitInt(sampleHeaderData, 24)),\n        volume:       Math.min(utils.read8bitInt(sampleHeaderData, 25), 64),\n        repeatOffset: utils.readBigEndian16bitInt(sampleHeaderData, 26) * 2,\n        repeatLength: utils.readBigEndian16bitInt(sampleHeaderData, 28) * 2\n    }\n};\n\n\n","import { getInitOptions as getProtrackerInitOptions } from '../players/Protracker/ProtrackerReader';\n\nexport interface PlayerInitInfo {\n    name: string,\n    getInitOptions: (fileData: ArrayBuffer) => AudioWorkletNodeOptions,\n    options: AudioWorkletNodeOptions,\n    path: string\n}\n\nconst players:PlayerInitInfo[] = [\n    {\n        name: 'protracker',\n        getInitOptions: getProtrackerInitOptions,\n        options: {},\n        path: process.env.PUBLIC_URL + '/players/protracker.js'\n    }\n];\n\nexport default players;","import players, { PlayerInitInfo } from './players/players';\nimport * as utils from './utils';\nimport { loadFile } from './utils';\n\nexport class Wurlitzer {\n    audioContext: AudioContext;\n    fileData: ArrayBuffer | undefined;\n    mixer: ChannelMergerNode | undefined;\n    player: AudioWorkletNode | undefined;\n    connected: boolean = false;\n    status: 'not-ready' | 'loading' | 'stopped' | 'ready' | 'loading' = 'not-ready';\n\n    constructor(audioContext?: AudioContext) {\n        this.audioContext = audioContext || utils.createAudioContext();\n    }\n\n    async load(source: string | File) {\n        const fileData = await loadFile(source);\n        const player = await loadPlayer(fileData, this.audioContext);\n\n        this.stop();\n        this.fileData = fileData;\n        this.player = player;\n        this.player.port.onmessage = this.onMessage;\n        this.mixer = addAmigaMixer(this.audioContext, this.player);\n        this.status = 'ready';\n    }\n\n    onMessage = (event: any) => {\n        if(event.data === 'ended') {\n            console.info('[Wurlitzer] - Song has ended');\n            this.stop();\n        }\n    }\n\n    pause() {\n        if(this.player && this.status === 'ready') {\n            this._disconnect();\n            this.player.port.postMessage({cmd: 'pause'});\n        }\n    }\n\n    async play() {\n        if(this.fileData && this.status === 'stopped') {\n            this.player = await loadPlayer(this.fileData, this.audioContext);\n            this.player.port.onmessage = this.onMessage;\n            this.mixer = addAmigaMixer(this.audioContext, this.player);\n            this.status = 'ready';\n        }\n\n        if(this.player && this.status === 'ready') {\n            this._connect();\n            this.player.port.postMessage({cmd: 'play'});\n        }\n    }\n\n    previousSubtrack() {\n        this.player && this.player.port.postMessage({cmd: 'previousSubtrack'});\n    }\n\n    nextSubtrack() {\n        this.player && this.player.port.postMessage({cmd: 'nextSubtrack'});\n    }\n\n    reset() {\n        this.player && this.player.port.postMessage({cmd: 'reset'});\n    }\n\n    setSubtrack(index: number) {\n        this.player && this.player.port.postMessage({cmd: 'setSubtrack', data: index});\n    }\n\n    skipToPosition(newPosition: number) {\n        this.player && this.player.port.postMessage({cmd: 'skipToPosition', data: newPosition});\n    }\n\n    stop() {\n        if(this.player && this.status === 'ready') {\n            this._disconnect();\n            this.player.port.postMessage({cmd: 'stop'});\n            this.status = 'stopped';\n        }\n    }\n\n    private _connect() {\n        if(this.mixer && !this.connected) {\n            this.mixer.connect(this.audioContext.destination);\n            this.connected = true;\n        }\n    }\n\n    private _disconnect() {\n        if(this.mixer && this.connected) {\n            this.mixer.disconnect();\n            this.connected = false;\n        }\n    }\n}\n\n\n// Utility functions\nexport function addAmigaMixer(audioContext: AudioContext, player: AudioWorkletNode): ChannelMergerNode {\n    const mixer = new ChannelMergerNode(audioContext, { numberOfInputs: 2 });\n\n    // If song has 4 channels, mimick amiga left/right split (LRRL)\n    if(player.numberOfOutputs === 4) {\n        [0,3].forEach(index => player.connect(mixer, index, 0));\n        [1,2].forEach(index => player.connect(mixer, index, 1));\n    }\n    // Otherwise, just assume the channels alternate (LRLRLR...)\n    else {\n        [...new Array(player.numberOfOutputs)]\n            .map((item, index) => index)\n            .filter(index => index % 2 === 0)\n            .forEach(index => player.connect(mixer, index, 0));\n\n        [...new Array(player.numberOfOutputs)]\n            .map((item, index) => index)\n            .filter(index => index % 2 !== 0)\n            .forEach(index => player.connect(mixer, index, 1));\n    }\n\n    return mixer;\n}\n\nexport async function loadPlayer(fileData: ArrayBuffer, audioContext: AudioContext): Promise<AudioWorkletNode> {\n    let requiredPlayer:PlayerInitInfo | undefined;\n\n    players.forEach(player => {\n        try {\n            requiredPlayer = {...player, options: player.getInitOptions(fileData)}\n        }\n        catch(e) {\n            // We get here if the player does not support the song (or something went wrong), continue to try other players\n        }\n    });\n\n    if(!requiredPlayer) {\n        throw new Error('This file is not supported');\n    }\n\n    try {\n        return new AudioWorkletNode(audioContext, requiredPlayer.name, requiredPlayer.options);\n    }\n    catch(e) {\n        await audioContext.audioWorklet.addModule(requiredPlayer.path);\n        return new AudioWorkletNode(audioContext, requiredPlayer.name, requiredPlayer.options);\n    }\n}\n\nexport default Wurlitzer;","import React, { FunctionComponent } from 'react';\nimport css from './Box.module.scss';\n\ntype BoxProps = {\n    orange?: boolean\n}\n\nconst box:FunctionComponent<BoxProps> = props => (\n    <div className={`${css.Box} ${props.orange ? css.orange : ''}`} {...props}>\n        {props.children}\n    </div>\n);\n\nexport default box;","import React, { FunctionComponent } from 'react';\nimport css from './Grid.module.scss';\n\ntype GridProps = {\n\n}\n\nconst grid:FunctionComponent<GridProps> = props => (\n    <div className={css.Grid}>{props.children}</div>\n);\n\nexport default grid;","import React, { FunctionComponent } from 'react';\nimport css from './Header.module.scss';\n\ntype HeaderProps = {\n\n}\n\nconst header:FunctionComponent<HeaderProps> = props => (\n    <header className={css.header}>\n        <h1>Floppy Disk Music</h1>\n        <h2>Javascript retro music player</h2>\n    </header>\n)\n\nexport default header;","import React, { FunctionComponent } from 'react';\nimport css from './IconButton.module.scss';\n\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { IconDefinition } from '@fortawesome/fontawesome-svg-core';\n\ntype IconButtonProps = {\n    onClick: () => void,\n    icon: IconDefinition,\n    title?: string,\n}\n\nconst iconButton:FunctionComponent<IconButtonProps> = props => (\n    <button type=\"button\" className={css.IconButton} onClick={props.onClick} title={props.title}>\n        <FontAwesomeIcon icon={props.icon} className={css.icon}/>\n    </button>\n);\n\nexport default iconButton;","import React, { FunctionComponent } from 'react';\nimport css from './PlayerControls.module.scss';\nimport { SongListing } from '../../SongList/SongList';\nimport IconButton from '../../UI/IconButton/IconButton';\n\nimport { faPlayCircle } from '@fortawesome/free-solid-svg-icons';\nimport { faPauseCircle } from '@fortawesome/free-solid-svg-icons';\nimport { faStopCircle } from '@fortawesome/free-solid-svg-icons';\n\ntype PlayerControlsProps = {\n    play: () => any,\n    pause: () => any,\n    stop: () => any,\n    ready: boolean,\n    currentSong: SongListing\n}\n\nconst PlayerControls:FunctionComponent<PlayerControlsProps> = props => (\n    <>\n        <div className={css.imageContainer}>\n            {boxImage(props.currentSong)}\n        </div>\n        <p>\n            <strong className={css.songName}>\n                {props.currentSong.name}\n            </strong>\n            <br/>\n            {`${props.currentSong.format}, ${props.currentSong.channels} channels, ${props.currentSong.size}`}\n        </p>\n        <div className={css.buttons}>\n            <IconButton icon={faPlayCircle} onClick={props.play} title=\"Play\"/>\n            <IconButton icon={faPauseCircle} onClick={props.pause} title=\"Pause\"/>\n            <IconButton icon={faStopCircle} onClick={props.stop} title=\"Stop\"/>\n        </div>\n    </>\n)\n\nconst boxImage = (song: SongListing):React.ReactElement => (\n    <img className={css.boxImage} src={`${process.env.PUBLIC_URL}/img/boxes/${song.image || 'unknown.jpg'}`} alt={song.name}/>\n)\n\nexport default PlayerControls;\n\n\n","import React, { FunctionComponent } from 'react';\nimport css from './IconLink.module.scss';\n\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { IconDefinition } from '@fortawesome/fontawesome-svg-core';\n\ntype IconLinkProps = {\n    href: string,\n    icon: IconDefinition,\n    title?: string,\n}\n\nconst iconLink:FunctionComponent<IconLinkProps> = props => (\n    <a href={props.href} className={css.IconLink} title={props.title}>\n        <FontAwesomeIcon icon={props.icon} className={css.icon}/>\n    </a>\n);\n\nexport default iconLink;","import React, { FunctionComponent } from 'react';\nimport css from './SongList.module.scss';\n\nimport IconButton from '../UI/IconButton/IconButton';\nimport IconLink from '../UI/IconLink/IconLink';\n\nimport { faPlayCircle } from '@fortawesome/free-solid-svg-icons'\nimport { faFileDownload } from '@fortawesome/free-solid-svg-icons'\n\n\n\nexport type SongListProps = {\n    list: SongListing[]\n    load: (song:SongListing) => any\n}\n\nexport type SongListing = {\n    src: string,\n    name: string,\n    format: string,\n    channels: number,\n    image?: string,\n    size: string\n}\n\nconst songList:FunctionComponent<SongListProps> = props => (\n    <>\n        <table className={css.songTable}>\n            <thead>\n                <tr>\n                    <th>Title</th>\n                    <th>Format</th>\n                    <th>Channels</th>\n                    <th>Size</th>\n                    <th>&nbsp;</th>\n                </tr>\n            </thead>\n            <tbody>\n                {props.list.map(song => (\n                    <tr key={song.name}>\n                        <td>{song.name}</td>\n                        <td>{song.format}</td>\n                        <td>{song.channels}</td>\n                        <td>{song.size}</td>\n                        <td className={css.noWrap}>\n                            <IconButton icon={faPlayCircle} onClick={() => props.load(song)} title=\"Load and play\"/>\n                            <IconLink icon={faFileDownload} href={song.src} title=\"Download\"/>\n                        </td>\n                    </tr>\n                ))}\n            </tbody>\n        </table>\n\n        <ul className={css.mobileSongTable}>\n            {props.list.map(song => (\n                <li className={css.mobileSong} key={song.name}>\n                    <div>\n                        <strong className={css.mobileSongTitle}>{song.name}</strong>\n                        <div className={css.mobileSongInfo}>\n                            {`${song.format}, ${song.channels} channels, ${song.size}`}\n                        </div>\n                    </div>\n                    <div className={css.mobileSongControls}>\n                        <IconButton icon={faPlayCircle} onClick={() => props.load(song)} title=\"Load and play\"/>\n                        <IconLink icon={faFileDownload} href={song.src} title=\"Download\"/>\n                    </div>\n                </li>\n            ))}\n        </ul>\n    </>\n)\n\nexport default songList;","import React, { useState } from 'react';\nimport './App.css';\nimport { Wurlitzer } from 'wurlitzer';\n\nimport Box from './components/Box/Box';\nimport Grid from './components/Grid/Grid';\nimport Header from './components/Header/Header'\nimport PlayerControls from './components/Player/PlayerControls/PlayerControls'\nimport SongList, { SongListing } from './components/SongList/SongList'\n\nconst songs:SongListing[] = [\n    {src: `${process.env.PUBLIC_URL}/songs/dragonsfunk.mod`, name: \"Dragons Funk\", format: \"Protracker\", channels: 4, size: \"193KB\"},\n    {src: `${process.env.PUBLIC_URL}/songs/Skid_Row2.mod`, name: \"Skid Row 2\", format: \"Protracker\", channels: 4, size: \"47KB\"},\n    {src: `${process.env.PUBLIC_URL}/songs/SuperFrogTitle.mod`, name: \"Super Frog\", format: \"Protracker\", channels: 4, image: 'superfrog.jpg', size: \"74KB\"},\n    {src: `${process.env.PUBLIC_URL}/songs/too-speedy.mod`, name: \"Too Speedy\", format: \"Protracker\", channels: 4, size: \"37KB\"},\n    {src: `${process.env.PUBLIC_URL}/songs/wizkid_1.mod`, name: \"Wizkid round 1/8\", format: \"Protracker\", channels: 4, image: 'wizkid.jpg', size: \"38KB\"},\n    {src: `${process.env.PUBLIC_URL}/songs/bedroomd.mod`, name: \"Bedroom Door\", format: \"Protracker\", channels: 4, size: \"85KB\"},\n    {src: `${process.env.PUBLIC_URL}/songs/dsots-intro.mod`, name: \"The Dark Side of the Spoon Intro\", format: \"Protracker\", channels: 4, size: \"179KB\"},\n    {src: `${process.env.PUBLIC_URL}/songs/moonclow.mod`, name: \"A Clown in the Moon\", format: \"Protracker\", channels: 8, size: \"211KB\"},\n    {src: `${process.env.PUBLIC_URL}/songs/ecodreams.mod`, name: \"Ecodreams\", format: \"Protracker\", channels: 4, size: \"29KB\"},\n    {src: `${process.env.PUBLIC_URL}/songs/wizard-2.mod`, name: \"Wizard2\", format: \"Protracker\", channels: 4, size: \"22KB\"},\n    {src: `${process.env.PUBLIC_URL}/songs/bitner.mod`, name: \"Bitner\", format: \"Protracker\", channels: 4, size: \"130KB\"},\n];\n\nfunction App() {\n    const [currentSong, setCurrentSong] = useState(undefined as SongListing | undefined);\n    const [ready, setReady] = useState(false);\n    const [player, setPlayer] = useState(undefined as Wurlitzer | undefined);\n\n    const play = () => {player && player.play()}\n    const pause = () => {player && player.pause()}\n    const stop = () => {player && player.stop()}\n\n    const load = (song: SongListing):void => {\n        let p = player || new Wurlitzer();\n        if(!player) setPlayer(p);\n\n        p.load(song.src).then(() => {\n            setCurrentSong(song);\n            setReady(true);\n            p.play();\n        });\n    }\n\n    return (\n        <div className=\"App\">\n            <Header/>\n            <Grid>\n                <Box>\n                    <SongList list={songs} load={load}/>\n                </Box>\n                <Box>\n                    {currentSong\n                        ? <PlayerControls {...{ready, play, pause, stop, currentSong}}/>\n                        : <p style={{textAlign: 'center'}}>No song loaded</p>\n                    }\n                </Box>\n            </Grid>\n        </div>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}